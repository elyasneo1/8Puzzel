<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        * {
            font-family: "dejavu sans mono";
        }

        html {
            height: 100%;
        }

        body {
            height: 100%;
            background-color: #222222;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0px;
        }

        .game {
            margin: auto 0;
        }

        .game-options {
            width: 300px;
            margin: auto 0;
            margin-right: 30px;
        }

        .puzzel {
            height: 100%;
            width: 100%;
            display: flex;
            justify-content: space-between;
            flex-direction: row;
        }

        .board {
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
            padding: 15px;
            background-color: #333333;
            border-radius: 5px;
        }

        .grid {
            display: grid;
            grid-template-columns: 90px 90px 90px;
            grid-template-rows: 90px 90px 90px;
            border-style: solid;
            border-color: #555555;
            border-width: 2px;
        }

        .grid button {
            background-color: #444444;
            outline: none;
            cursor: pointer;
            display: inline-block;
            margin: 5px;
            width: 76px;
            height: 76px;
            border: 2px solid #555555;
            line-height: 76px;
            font-size: 40px;
            text-align: center;
        }

        .footer {
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
        }

        .options {
            text-align: center;
            margin-top: 10px;
            margin-bottom: 5px;
        }

        .options button {
            border: none;
            font-size: 20px;
            font-weight: bold;
            border-radius: 5px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
            padding: 5px;
            width: 80px;
            background-color: #b38600;
            color: #555555;
            outline: none;
            cursor: pointer;
            outline: none;
            cursor: pointer;
        }

        .options button:hover {
            color: #b38600;
            background-color: #555555;
        }

        .footer p {
            flex: 1;
            text-align: center;
            font-size: 20px;
            color: #b38600;
            font-weight: bold;
            margin: auto 0;
        }

        .message {
            color: goldenrod;
            height: 80px;
        }

        .container {
            display: block;
            height: auto;
            width: 300px;
            padding: 0px;
            margin: auto 0;
            margin-left: 30px;
        }

        h2 {
            color: #AAAAAA;
        }

        .container ul {
            list-style: none;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        ul li {
            color: #AAAAAA;
            display: block;
            position: relative;
            float: left;
            width: 50%;
            height: 80px;
            border-bottom: 1px solid #b38600;
            margin-bottom: 2px;
            margin-left: 5px;
        }

        ul li input[type=radio] {
            position: absolute;
            visibility: hidden;
        }

        ul li label {
            display: block;
            position: relative;
            font-weight: 300;
            font-size: 1.35em;
            padding: 25px 25px 25px 80px;
            margin: 10px auto;
            height: 30px;
            z-index: 9;
            cursor: pointer;
        }

        ul li:hover label {
            color: #FFFFFF;
        }

        ul li .check {
            display: block;
            position: absolute;
            border: 5px solid #AAAAAA;
            border-radius: 100%;
            height: 25px;
            width: 25px;
            top: 30px;
            left: 20px;
            z-index: 5;
            transition: border .25s linear;
        }

        ul li:hover .check {
            border: 5px solid #FFFFFF;
        }

        ul li .check::before {
            display: block;
            position: absolute;
            content: '';
            border-radius: 100%;
            height: 15px;
            width: 15px;
            top: 5px;
            left: 5px;
            margin: auto;
            transition: background 0.25s linear;
        }

        input[type=radio]:checked~.check {
            border: 5px solid #b38600;
        }

        input[type=radio]:checked~.check::before {
            background: #b38600;
        }

        input[type=radio]:checked~label {
            color: #b38600;
        }
    </style>
</head>

<body>
    <div class="puzzel">
        <div class="container board">
            <ul>
                <li>
                    <input type="radio" id="BFS-option" name="selector" value="BFS">
                    <label for="BFS-option">BFS</label>
                    <div class="check"></div>
                </li>

                <li>
                    <input type="radio" id="DLS-option" name="selector" value="DLS">
                    <label for="DLS-option">DLS</label>
                    <div class="check">
                        <div class="inside"></div>
                    </div>
                </li>

                <li>
                    <input type="radio" id="IDS-option" name="selector" value="IDS">
                    <label for="IDS-option">IDS</label>
                    <div class="check">
                        <div class="inside"></div>
                    </div>
                </li>

                <li>
                    <input type="radio" id="BDS-option" name="selector" value="BDS">
                    <label for="BDS-option">BDS</label>
                    <div class="check">
                        <div class="inside"></div>
                    </div>
                </li>
                <li>
                        <input type="radio" id="Astar-option" name="selector" value="Astar">
                        <label for="Astar-option">Astar</label>
                        <div class="check">
                            <div class="inside"></div>
                        </div>
                    </li>
            </ul>
        </div>
        <div class="game">
            <div class="board">
                <div class="grid">
                    <button>1</button>
                    <button name="2">2</button>
                    <button name="3">3</button>
                    <button name="4">4</button>
                    <button name="5">5</button>
                    <button name="6">6</button>
                    <button name="7">7</button>
                    <button name="8">8</button>
                    <button></button>
                </div>
                <div class="footer">
                    <p id="move">Move:100</p>
                    <p id="time">Time:100</p>
                </div>
            </div>
        </div>
        <div class="game-options board">
            <div class="options">
                <button id="play">Play</button>
            </div>
        </div>
    </div>
    <h1 class="message">You win!</h1>
    </div>
    <script>

        const playButton = document.getElementById("play");
        playButton.addEventListener("click", buttonAction);

        class Node {
            constructor(parent, value) {
                this.parent = parent;
                this.value = value;
                this.depth = 0;
                this.g = 0;
                this.h = 0;
                this.f = 0;
            }

        }

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            getTopCell() {
                if (this.y == 0) {
                    return null;
                } else {
                    return new Cell(this.x, this.y - 1);
                }
            }

            getRightCell() {
                if (this.x == 2) {
                    return null;
                } else {
                    return new Cell(this.x + 1, this.y);
                }
            }

            getBottomCell() {
                if (this.y == 2) {
                    return null;
                } else {
                    return new Cell(this.x, this.y + 1);
                }
            }

            getLeftCell() {
                if (this.x == 0) {
                    return null;
                } else {
                    return new Cell(this.x - 1, this.y);
                }
            }

            move() {
                return [
                    this.getTopCell(),
                    this.getBottomCell(),
                    this.getRightCell(),
                    this.getLeftCell()
                ].filter(Cell => Cell != null);
            }

            randomMove() {
                const moveChoice = this.move();
                return moveChoice[Math.floor(Math.random() * moveChoice.length)];
            }

        }

        function isSolved(grid) {
            return (
                grid[0][0] == 1 &&
                grid[0][1] == 2 &&
                grid[0][2] == 3 &&
                grid[1][0] == 4 &&
                grid[1][1] == 5 &&
                grid[1][2] == 6 &&
                grid[2][0] == 7 &&
                grid[2][1] == 8 &&
                grid[2][2] == 0
            );
        };

        function swap(grid, blank, move) {
            let temp = grid[blank.y][blank.x];
            grid[blank.y][blank.x] = grid[move.y][move.x];
            grid[move.y][move.x] = temp;
        }

        function getRandomGrid() {
            let grid = [
                [1, 2, 3],
                [4, 5, 6],
                [7, 8, 0]
            ];
            let blank = new Cell(2, 2);

            // shufle
            for (let i = 0; i < 1; i++) {
                const randomMove = blank.randomMove();
                swap(grid, blank, randomMove);
                blank = randomMove;
            }

            if (isSolved(grid)) {
                return getRandomGrid();
            }

            return grid;
        }

        class State {
            constructor(grid, move, time, status) {
                this.grid = grid;
                this.move = move;
                this.time = time;
                this.status = status;
            }

            static ready() {
                return new State([
                    [0, 0, 0],
                    [0, 0, 0],
                    [0, 0, 0]
                ], 0, 0, "ready");
            }

            static start(grid) {
                return new State(grid, 0, 0, "playing");
            }
        }

        function changeColor() {
            document.querySelectorAll(".grid button").forEach(element => {
                if (element.textContent == 0) {
                    element.style.color = "black";
                    element.style.background = "#333333";
                } else {
                    if (element.textContent == element.className) {
                        element.style.color = "#00ff00";
                    } else {
                        element.style.color = "#ff0000";
                    }
                }
            });

        }
        var tickId = undefined;
        var intId = undefined;
        var intId1 = undefined;
        var timeSpeed = 1000;
        class Game {
            constructor(state) {
                this.state = state;
                this.tickId = null;
                this.tick = this.tick.bind(this);
                this.render();
                this.handleClickBox = this.handleClickBox.bind(this);
            }

            static ready() {
                return new Game(State.ready());
            }

            setState(newState) {
                this.state = {
                    ...this.state,
                    ...newState
                };
                this.render();
            }

            tick() {
                this.setState({
                    time: this.state.time + 1
                });
                changeColor();
            }

            handleClickBox(cell) {
                return function () {
                    const move = cell.move();
                    const blank = move.find(
                        place => this.state.grid[place.y][place.x] == 0
                    );
                    if (blank) {
                        const newGrid = [...this.state.grid];
                        swap(newGrid, cell, blank);
                        if (isSolved(newGrid)) {
                            clearInterval(this.tickId);
                            this.setState({
                                status: "won",
                                grid: newGrid,
                                move: this.state.move + 1
                            });
                        } else {
                            this.setState({
                                grid: newGrid,
                                move: this.state.move + 1
                            });
                        }
                    }
                    changeColor();
                }.bind(this);
            }

            render() {
                const {
                    grid,
                    move,
                    time,
                    status
                } = this.state;

                // Render grid
                const newGrid = document.createElement("div");
                newGrid.className = "grid";
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const button = document.createElement("button");
                        button.className = i * 3 + j + 1;
                        // if (status == "playing") {
                        //     button.addEventListener("click", this.handleClickBox(new Cell(j, i)));
                        // }
                        button.textContent = grid[i][j].toString();
                        newGrid.appendChild(button);
                    }
                }
                document.querySelector(".grid").replaceWith(newGrid);

                // Render move
                document.getElementById("move").textContent = `Move: ${move}`;

                // Render time
                document.getElementById("time").textContent = `Time: ${time}`;

                // Render message
                if (status == "won") {
                    document.querySelector(".message").textContent = "You win!";
                } else {
                    document.querySelector(".message").textContent = "";
                }
            }
        }

        const GAME = Game.ready();
        document.getElementById("BFS-option").checked = true;
        ///////////////////////////////////////////////////////////////////////////Start to Solve////////////////////////////////////////////////////
        async function startToSolve(startNode) {
            var mStartNode;
            if (document.getElementById("BFS-option").checked) {
                mStartNode = await BFS(startNode)
            }
            if (document.getElementById("Astar-option").checked) {
                mStartNode = await A_Star(startNode, new Node(0, [
                    [1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 0]
                ]));
            }
            if (document.getElementById("BDS-option").checked) {
                mStartNode = await BDS(startNode, new Node(0, [
                    [1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 0]
                ]));
            }
            if (document.getElementById("IDS-option").checked) {
                mStartNode = await IDS(startNode, 1);
            }
            if (document.getElementById("DLS-option").checked) {
                mStartNode = await DLS(startNode, 10);
            }

            var road = getRoad(mStartNode);
            GAME.setState(State.start(road[0].value));
            changeColor();
            sleep(500);
            road.shift();
            if (road.length != 0) {
                intId = setInterval(function () {
                    GAME.setState({
                        grid: road.shift().value,
                        move: GAME.state.move + 1
                    })
                    changeColor();
                    if (road.length === 0) {
                        clearInterval(intId);
                        clearInterval(GAME.tickId);
                        GAME.setState({
                            status: "won",
                        });
                        changeColor();
                        buttonAction();
                    }
                }, timeSpeed);
            } else {
                clearInterval(GAME.tickId);
                GAME.setState({
                    status: "playing",
                });
                changeColor();
                buttonAction();
            }
        }

        function findBlankInGridASCell(grid) {
            var blank;
            for (let i = 0; i <= 2; i++) {
                for (let j = 0; j <= 2; j++) {
                    if (grid[i][j] == 0)
                        blank = new Cell(i, j);
                }
            }
            return blank;
        }

        function mSwap(grid, blank, move) {
            [grid[blank.x][blank.y], grid[move.x][move.y]] = [grid[move.x][move.y], grid[blank.x][blank.y]]
        }

        function alternative(grid) {
            var blank = findBlankInGridASCell(grid.value);
            const moveChoices = blank.move();
            var childs = createChild(grid, blank, moveChoices);
            return childs;
        }

        function createChild(grid, blank, moves) {
            var childs = [];
            for (let move of moves) {
                var child = copyGrid(grid.value);
                mSwap(child, blank, move);
                newChild = new Node(grid, child)
                if (newChild.parent != 0) {
                    newChild.depth = newChild.parent.depth + 1;
                    newChild.g = newChild.parent.g + 1;
                }
                newChild.h = hurestics(newChild)
                newChild.f = newChild.h + newChild.g
                childs.push(newChild);
            }
            return childs;
        }

        function contains(array, node) {
            //             for (let i = 0; i < array.length; i++) {
            //  if (array[i].value.toString() === node.value.toString()) {
            //                     return i
            //                 }
            //             }
            //             return -1
            var r = array.find(e => {
                return e.value.toString() === node.value.toString()
            })
            return r;
        }

        function copyGrid(grid) {
            var mGrid = [];
            for (var i = 0; i < grid.length; i++)
                mGrid[i] = grid[i].slice();
            return mGrid;
        }

        function shuffle(array) {
            array.sort(() => Math.random() - 0.5);
        }
        ///////////////////////////////////////////////////////////////////////////////////////// search Algorithm ///////////////////////////////////////////////////  
        const mtop = 0;
        const parent = i => ((i + 1) >>> 1) - 1;
        const left = i => (i << 1) + 1;
        const right = i => (i + 1) << 1;

        class PriorityQueue {
            constructor(comparator = (a, b) => a.f < b.f) {
                this._heap = [];
                this._comparator = comparator;
            }
            size() {
                return this._heap.length;
            }
            isEmpty() {
                return this.size() == 0;
            }
            peek() {
                return this._heap[mtop];
            }
            push(...values) {
                values.forEach(value => {
                    this._heap.push(value);
                    this._siftUp();
                });
                return this.size();
            }
            pop() {
                const poppedValue = this.peek();
                const bottom = this.size() - 1;
                if (bottom > mtop) {
                    this._swap(mtop, bottom);
                }
                this._heap.pop();
                this._siftDown();
                return poppedValue;
            }
            replace(value) {
                const replacedValue = this.peek();
                this._heap[mtop] = value;
                this._siftDown();
                return replacedValue;
            }
            _greater(i, j) {
                return this._comparator(this._heap[i], this._heap[j]);
            }
            _swap(i, j) {
                [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];
            }
            _siftUp() {
                let node = this.size() - 1;
                while (node > mtop && this._greater(node, parent(node))) {
                    this._swap(node, parent(node));
                    node = parent(node);
                }
            }
            _siftDown() {
                let node = mtop;
                while (
                    (left(node) < this.size() && this._greater(left(node), node)) ||
                    (right(node) < this.size() && this._greater(right(node), node))
                ) {
                    let maxChild = (right(node) < this.size() && this._greater(right(node), left(node))) ? right(node) : left(node);
                    this._swap(node, maxChild);
                    node = maxChild;
                }
            }
        }


        function hurestics(node) {
            var sum = 0;
            for (var i = 0; i < node.value.length; i++) {
                for (var j = 0; j < node.value.length; j++) {
                    if (node.value[i][j] != 0) {
                        var x = node.value[i][j] / 3;
                        var y = (node.value[i][j] % 3) - 1;
                        var s = Math.abs(x - i) + Math.abs(y - j)
                        sum += s;
                    }
                }
            }
            return sum;
        }

        function A_Star(start, target) {
            return new Promise(resolve => {
                var q = new PriorityQueue();
                q.push(start)
                intId1 = setInterval(function () {
                    current = q.pop();
                    console.log(current);

                    GAME.setState({
                        grid: current.value,
                        move: GAME.state.move + 1,
                        status: "playing"
                    })
                    changeColor();
                    if (isSolved(current.value)) {
                        clearInterval(GAME.tickId);
                        changeColor();
                        clearInterval(intId1);
                        return resolve(current);
                    } else {
                        addToQ(q, alternative(current))
                    }
                }, 2);
            })

        }

        function BDS(start, target) {
            return new Promise(resolve => {
                var res = {
                    fromStart: null,
                    fromEnd: null
                }
                var qStart = [start];
                var qTarget = [target];
                var startVisited = []
                var targetVisited = []
                intId1 = setInterval(function () {
                    var current = qStart.shift();
                    GAME.setState({
                        grid: current.value,
                        move: GAME.state.move + 1,
                        status: "playing"
                    })
                    changeColor();
                    var index = contains(targetVisited, current);
                    if (index) {
                        clearInterval(intId1);
                        clearInterval(GAME.tickId);
                        changeColor();
                        res.fromStart = current
                        res.fromEnd = index
                        return resolve(res);
                    } else {
                        addToQ(qStart, alternative(current))
                        if (!contains(startVisited, current))
                            startVisited.push(current)
                    }


                    var current = qTarget.shift();
                    GAME.setState({
                        grid: current.value,
                        move: GAME.state.move + 1,
                        status: "playing"
                    })
                    changeColor();
                    var index = contains(startVisited, current);
                    if (index) {
                        clearInterval(intId1);

                        clearInterval(GAME.tickId);
                        changeColor();
                        res.fromStart = current
                        res.fromEnd = index
                        return resolve(res);
                    } else {

                        console.log(current.value);
                        var childs = alternative(current)
                        // shuffle(childs)
                        addToQ(qTarget, childs)
                        if (!contains(targetVisited, current))
                            targetVisited.push(current)
                    }

                }, 2);

            })
        }

        function BFS(start) {
            return new Promise(resolve => {
                var q = [start];
                intId1 = setInterval(function () {
                    current = q.shift();
                    GAME.setState({
                        grid: current.value,
                        move: GAME.state.move + 1,
                        status: "playing"
                    })
                    changeColor();
                    if (isSolved(current.value)) {
                        clearInterval(GAME.tickId);
                        changeColor();
                        clearInterval(intId1);


                        return resolve(current);
                    } else {
                        addToQ(q, alternative(current))
                    }
                }, 2);
            })

        }

        function addToQ(base, arr) {
            arr.forEach(element => {
                base.push(element);
            });
        }

        function getRoad(mTargetNode) {
            if (mTargetNode instanceof Node) {
                var targetNode = mTargetNode;
                var road = [targetNode];
                console.log(road);
                while (targetNode.parent != 0) {
                    if (!contains(road, targetNode.parent))
                        road.push(targetNode.parent);
                    targetNode = targetNode.parent;
                }

                return road.reverse()
            } else {
                var sRoad = []
                var fromStart = mTargetNode.fromStart;
                while (fromStart.parent != 0) {
                    sRoad.push(fromStart.parent)
                    fromStart = fromStart.parent
                }
                var eRoad = [mTargetNode.fromEnd]
                var fromEnd = mTargetNode.fromEnd;
                while (fromEnd.parent != 0) {
                    eRoad.push(fromEnd.parent)
                    fromEnd = fromEnd.parent
                }
                var res = [...sRoad.reverse(), ...eRoad]
                if (isSolved(res[0].value))
                    res.reverse()
                return res;
            }


        }

        function buttonAction() {
            if (GAME.state.status == "playing") {
                playButton.textContent = "play";
                clearInterval(tickId);
                clearInterval(intId);
                clearInterval(intId1);
                GAME.setState({
                    grid: [
                        [0, 0, 0],
                        [0, 0, 0],
                        [0, 0, 0]
                    ],
                    status: "ready",
                    move: 0,
                    time: 0
                })
            } else if (GAME.state.status == "ready") {
                playButton.textContent = "reset";
                tickId = setInterval(GAME.tick, 1000);
                changeColor();
                startToSolve(new Node(0, [[5, 0, 3], [2, 1, 7], [4, 8, 6]]));
                // [[5, 0, 3], [2, 1, 7], [4, 8, 6]] high
                // [[0, 2, 6], [1, 3, 5], [4, 7, 8]] medium 21743
                // [[0, 2, 3], [1, 5, 6], [4, 7, 8]] small 63
            } else if (GAME.state.status == "won") {
                playButton.textContent = "play";
                clearInterval(tickId);
                clearInterval(intId);
                clearInterval(intId1);
                GAME.setState({
                    status: "ready"
                })
                changeColor();
            }
        }

        function DLS(start, depthLimit) {
            return new Promise(resolve => {
                var q = [start];
                intId1 = setInterval(function () {
                    current = q.pop();
                    if (current.depth < depthLimit) {
                        GAME.setState({
                            grid: current.value,
                            move: GAME.state.move + 1,
                            status: "playing"
                        })
                        changeColor();
                        if (isSolved(current.value)) {
                            clearInterval(intId1);
                            clearInterval(GAME.tickId);
                            changeColor();
                            return resolve(current);
                        } else {
                            addToQ(q, alternative(current))
                        }
                    }
                    if (q.length == 0) {
                        clearInterval(intId1);
                        clearInterval(GAME.tickId);
                        changeColor();
                        return resolve(start);
                    }
                }, timeSpeed / 100)
            })
        }

        function IDS(start, depthLimit) {
            return new Promise(resolve => {
                let q = [start];
                intId1 = setInterval(function () {
                    current = q.pop();
                    if (current.depth < depthLimit) {
                        GAME.setState({
                            grid: current.value,
                            move: GAME.state.move + 1,
                            status: "playing"
                        })
                        changeColor();
                        if (isSolved(current.value)) {
                            clearInterval(intId1);
                            clearInterval(GAME.tickId);
                            changeColor();
                            return resolve(current);
                        } else {
                            addToQ(q, alternative(current))
                        }
                    }
                    if (q.length == 0) {
                        q.push(start);
                        console.log("not found in depth " + depthLimit);

                        depthLimit = depthLimit + 1;
                    }
                }, timeSpeed / 100)
            })
        }

        function sleep(milliseconds) {
            var start = new Date().getTime();
            for (var i = 0; i < 1e7; i++) {
                if ((new Date().getTime() - start) > milliseconds) {
                    break;
                }
            }
        }
    </script>
</body>

</html>